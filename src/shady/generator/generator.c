#include "util.h"
#include "log.h"
#include "growy.h"

#include <json-c/json.h>
#include <assert.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

typedef const char* String;

static bool should_include_instruction(json_object* instruction) {
    String class = json_object_get_string(json_object_object_get(instruction, "class"));
    if (strcmp(class, "@exclude") == 0)
        return false;
    return true;
}

static void add_comments(Growy* g, String indent, json_object* comments) {
    if (!indent)
        indent = "";
    if (json_object_get_type(comments) == json_type_string) {
        growy_append_formatted(g, "%s/// %s\n", indent, json_object_get_string(comments));
    } else if (json_object_get_type(comments) == json_type_array) {
        size_t size = json_object_array_length(comments);
        for (size_t i = 0; i < size; i++)
            add_comments(g, indent, json_object_array_get_idx(comments, i));
    }
}

static void generate_grammar_header(Growy* g, json_object* shd, json_object* spv) {
    int32_t major = json_object_get_int(json_object_object_get(spv, "major_version"));
    int32_t minor = json_object_get_int(json_object_object_get(spv, "minor_version"));
    int32_t revision = json_object_get_int(json_object_object_get(spv, "revision"));
    growy_append_formatted(g, "/* generated header from SPIR-V %d.%d revision %d */\n", major, minor, revision);
    growy_append_formatted(g, "/* Do not edit this file manually ! */\n");
    growy_append_formatted(g, "/* It is generated by the 'generator' target using Json grammar files. */\n");

    /*json_object* instructions = json_object_object_get(spv, "instructions");
    for (size_t i = 0; i < json_object_array_length(instructions); i++) {
        json_object* instruction = json_object_array_get_idx(instructions, i);
        String opname = json_object_get_string(json_object_object_get(instruction, "opname"));
        if (!should_include_instruction(instruction))
            continue;
        growy_append_formatted(g, "typedef struct %s_ {\n", opname);
        growy_append_formatted(g, "} %s\n\n", opname);
    }*/

    json_object* address_spaces = json_object_object_get(shd, "address_spaces");

    growy_append_formatted(g, "typedef enum AddressSpace_ {\n");
    for (size_t i = 0; i < json_object_array_length(address_spaces); i++) {
        json_object* as = json_object_array_get_idx(address_spaces, i);
        String name = json_object_get_string(json_object_object_get(as, "name"));
        add_comments(g, "\t", json_object_object_get(as, "description"));
        growy_append_formatted(g, "\tAs%s,\n", name);
    }
    growy_append_formatted(g, "\tNumAddressSpaces,\n");
    growy_append_formatted(g, "} AddressSpace;\n\n");

    growy_append_formatted(g, "static inline bool is_physical_as(AddressSpace as) {\n");
    growy_append_formatted(g, "\tswitch(as) {\n");
    for (size_t i = 0; i < json_object_array_length(address_spaces); i++) {
        json_object* as = json_object_array_get_idx(address_spaces, i);
        String name = json_object_get_string(json_object_object_get(as, "name"));
        if (json_object_get_boolean(json_object_object_get(as, "physical")))
            growy_append_formatted(g, "\t\tcase As%s: return true;\n", name);
    }
    growy_append_formatted(g, "\t\tdefault: return false;\n");
    growy_append_formatted(g, "\t}\n");
    growy_append_formatted(g, "}\n");
}

enum {
    ArgSelf = 0,
    ArgGeneratorFn,
    ArgDstFile,
    ArgShadyJson,
    ArgSpirvGrammarSearchPathBegins
};

int main(int argc, char** argv) {
    assert(argc > ArgSpirvGrammarSearchPathBegins);

    char* mode = argv[ArgGeneratorFn];
    char* dst_file = argv[ArgDstFile];
    char* shd_grammar_json_path = argv[ArgShadyJson];
    // search the include path for spirv.core.grammar.json
    char* spv_core_json_path = NULL;
    for (size_t i = ArgSpirvGrammarSearchPathBegins; i < argc; i++) {
        char* path = format_string_new("%s/spirv/unified1/spirv.core.grammar.json", argv[i]);
        info_print("trying path %s\n", path);
        FILE* f = fopen(path, "rb");
        if (f) {
            spv_core_json_path = path;
            fclose(f);
            break;
        }
        free(path);
    }

    if (!spv_core_json_path)
        abort();

    json_tokener* tokener = json_tokener_new_ex(32);
    enum json_tokener_error json_err;

    struct {
        size_t size;
        char* contents;
        json_object* root;
    } shd_grammar;
    read_file(shd_grammar_json_path, &shd_grammar.size, &shd_grammar.contents);
    shd_grammar.root = json_tokener_parse_ex(tokener, shd_grammar.contents, shd_grammar.size);
    json_err = json_tokener_get_error(tokener);
    if (json_err != json_tokener_success) {
        error("Json tokener error: %s\n", json_tokener_error_desc(json_err));
    }

    struct {
        size_t size;
        char* contents;
        json_object* root;
    } spv_grammar;

    read_file(spv_core_json_path, &spv_grammar.size, &spv_grammar.contents);
    spv_grammar.root = json_tokener_parse_ex(tokener, spv_grammar.contents, spv_grammar.size);
    json_err = json_tokener_get_error(tokener);
    if (json_err != json_tokener_success) {
        error("Json tokener error: %s\n", json_tokener_error_desc(json_err));
    }

    info_print("Correctly opened json file: %s\n", spv_core_json_path);
    Growy* g = new_growy();

    if (strcmp(mode, "grammar-headers") == 0) {
        generate_grammar_header(g, shd_grammar.root, spv_grammar.root);
    } else {
        error_print("Unknown mode '%s'\n", mode);
        exit(-1);
    }

    size_t final_size = growy_size(g);
    growy_append_bytes(g, 1, (char[]) { 0 });
    char* generated = growy_deconstruct(g);
    info_print("debug: %s\n", generated);
    write_file(dst_file, final_size, generated);
    free(shd_grammar.contents);
    free(spv_grammar.contents);
    free(generated);

    // dump_module(mod);

    json_object_put(shd_grammar.root);
    json_object_put(spv_grammar.root);
    json_tokener_free(tokener);
    free(spv_core_json_path);
}