#include "generator.h"

static bool should_include_instruction(json_object* instruction) {
    String class = json_object_get_string(json_object_object_get(instruction, "class"));
    if (strcmp(class, "@exclude") == 0)
        return false;
    return true;
}

void add_comments(Growy* g, String indent, json_object* comments) {
    if (!indent)
        indent = "";
    if (json_object_get_type(comments) == json_type_string) {
        growy_append_formatted(g, "%s/// %s\n", indent, json_object_get_string(comments));
    } else if (json_object_get_type(comments) == json_type_array) {
        size_t size = json_object_array_length(comments);
        for (size_t i = 0; i < size; i++)
            add_comments(g, indent, json_object_array_get_idx(comments, i));
    }
}

String to_snake_case(String camel) {
    size_t camel_len = strlen(camel);
    size_t buffer_size = camel_len + 16;
    char* dst = malloc(buffer_size);
    while (true) {
        size_t j = 0;
        for (size_t i = 0; i < camel_len; i++) {
            if (j >= buffer_size)
                goto start_over;
            if (isupper(camel[i])) {
                if (i > 0 && !isupper(camel[i - 1]))
                    dst[j++] = '_';
                dst[j++] = tolower(camel[i]);
            } else {
                dst[j++] = camel[i];
            }
        }

        // null terminate if we have space
        if (j + 1 < buffer_size) {
            dst[j] = '\0';
            return dst;
        }

        start_over:
        buffer_size += 16;
        dst = realloc(dst, buffer_size);
    }
}

String capitalize(String str) {
    size_t len = strlen(str);
    assert(len > 0);
    size_t buffer_size = len + 1;
    char* dst = malloc(buffer_size);
    dst[0] = toupper(str[0]);
    for (size_t i = 1; i < len; i++) {
        dst[i] = str[i];
    }
    dst[len] = '\0';
    return dst;
}

void generate_header(Growy* g, Data data) {
    int32_t major = json_object_get_int(json_object_object_get(data.spv, "major_version"));
    int32_t minor = json_object_get_int(json_object_object_get(data.spv, "minor_version"));
    int32_t revision = json_object_get_int(json_object_object_get(data.spv, "revision"));
    growy_append_formatted(g, "/* Generated from SPIR-V %d.%d revision %d */\n", major, minor, revision);
    growy_append_formatted(g, "/* Do not edit this file manually ! */\n");
    growy_append_formatted(g, "/* It is generated by the 'generator' target using Json grammar files. */\n\n");
}

bool starts_with_vowel(String str) {
    char vowels[] = { 'a', 'e', 'i', 'o', 'u' };
    for (size_t i = 0; i < (sizeof(vowels) / sizeof(char)); i++) {
        if (str[0] == vowels[i]) {
            return true;
        }
    }
    return false;
}

enum {
    ArgSelf = 0,
    ArgDstFile,
    ArgShadyGrammarJson,
    ArgShadyPrimopsJson,
    ArgSpirvGrammarSearchPathBegins
};

int main(int argc, char** argv) {
    assert(argc > ArgSpirvGrammarSearchPathBegins);

    //char* mode = argv[ArgGeneratorFn];
    char* dst_file = argv[ArgDstFile];
    char* shd_grammar_json_path = argv[ArgShadyGrammarJson];
    char* shd_primops_json_path = argv[ArgShadyPrimopsJson];
    // search the include path for spirv.core.grammar.json
    char* spv_core_json_path = NULL;
    for (size_t i = ArgSpirvGrammarSearchPathBegins; i < argc; i++) {
        char* path = format_string_new("%s/spirv/unified1/spirv.core.grammar.json", argv[i]);
        info_print("trying path %s\n", path);
        FILE* f = fopen(path, "rb");
        if (f) {
            spv_core_json_path = path;
            fclose(f);
            break;
        }
        free(path);
    }

    if (!spv_core_json_path)
        abort();

    json_tokener* tokener = json_tokener_new_ex(32);
    enum json_tokener_error json_err;

    typedef struct {
        size_t size;
        char* contents;
        json_object* root;
    } JsonFile;

    String json_paths[3] = { shd_grammar_json_path, shd_primops_json_path, spv_core_json_path };
    JsonFile json_files[3];
    for (size_t i = 0; i < sizeof(json_files) / sizeof(json_files[0]); i++) {
        String path = json_paths[i];
        read_file(path, &json_files[i].size, &json_files[i].contents);
        json_files[i].root = json_tokener_parse_ex(tokener, json_files[i].contents, json_files[i].size);
        json_err = json_tokener_get_error(tokener);
        if (json_err != json_tokener_success) {
            error("Json tokener error while parsing %s:\n %s\n", path, json_tokener_error_desc(json_err));
        }

        info_print("Correctly opened json file: %s\n", path);
    }
    Growy* g = new_growy();

    Data data = {
        .shd = json_object_new_object(),
        .spv = json_files[2].root,
    };

    for (size_t i = 0; i < 2; i++) {
        json_apply_object(data.shd, json_files[i].root);
    }

    generate(g, data);

    size_t final_size = growy_size(g);
    growy_append_bytes(g, 1, (char[]) { 0 });
    char* generated = growy_deconstruct(g);
    debug_print("debug: %s\n", generated);
    if (!write_file(dst_file, final_size, generated)) {
        error_print("Failed to write file '%s'\n", dst_file);
        error_die();
    }
    free(generated);
    for (size_t i = 0; i < sizeof(json_files) / sizeof(json_files[0]); i++) {
        free(json_files[i].contents);
        json_object_put(json_files[i].root);
    }
    json_object_put(data.shd);
    json_tokener_free(tokener);
    free(spv_core_json_path);
}
